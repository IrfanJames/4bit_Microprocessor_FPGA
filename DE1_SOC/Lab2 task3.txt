Task1:
	assign HEX5[0] = ~SW[0];				//a
	assign HEX5[1] = ~( ~SW[0]|SW[1]);	//b
	assign HEX5[2] = ~(~SW[0]|SW[1]);	//c
	assign HEX5[3] = ~(SW[0]|~SW[1]);	//d
	assign HEX5[4] = ~(SW[0]|~SW[1]);	//e
	assign HEX5[5] = ~SW[0];				//f
	assign HEX5[6] = SW[1];					//g
	
	assign HEX0[6:0]	= 7'b1111111;
	assign HEX1[6:0]	= 7'b1111111;
	assign HEX2[6:0]	= 7'b1111111;
	assign HEX3[6:0]	= 7'b1111111;
	assign HEX4[6:0]	= 7'b1111111;

________________________________________________________________________
Task2:
	assign HEX4[6:0]	= 7'b1111111;
   assign HEX5[6:0]	= 7'b1111111;
	wire [7:0] M0;
	
	rotate U0 (SW[9:8], M0);

   char_7seg H0 (M0[7:6], HEX0);
   char_7seg H1 (M0[5:4], HEX1);
   char_7seg H2 (M0[3:2], HEX2);
   char_7seg H3 (M0[1:0], HEX3);

//=======================================================
//  Structural coding
//=======================================================
endmodule

// implements a 7-segment decoder for d, E, 1 and 0
module char_7seg (C, Display);
	input [1:0] C; // input code
	output [6:0] Display; // output 7-seg code

	assign Display[0] = ~C[1];				//a
	assign Display[1] = ~(~C[1]|C[0]);	//b
	assign Display[2] = ~(~C[1]|C[0]);	//c
	assign Display[3] = ~(C[1]|~C[0]);	//d
	assign Display[4] = ~(C[1]|~C[0]); 	//e
	assign Display[5] = ~C[1];				//f
	assign Display[6] = C[0];				//g
endmodule

// 2-8 Decoder for Circuilar Rotation
module rotate (in, out);
	input [1:0] in; // input code
	output [7:0] out; // output 7-seg code

	assign out[0] = (in[1]);				//7
	assign out[1] = (in[0]);				//6
	assign out[2] = (in[1]^in[0]);		//5
	assign out[3] = (~in[0]);				//4
	assign out[4] = (~in[1]);				//3
	assign out[5] = (in[0]);				//2
	assign out[6] = (~(in[1]^in[0]));	//1
	assign out[7] = (~in[0]);				//0
endmodule
___________________________________________________________




Task -3 --Latest
____________

//=======================================================
//  REG/WIRE declarations
//=======================================================
	
	char_7seg u0(3'b000, HEX0);
	char_7seg u1(3'b001, HEX1);
	char_7seg u2(3'b010, HEX2);
	char_7seg u3(3'b011, HEX3);
	char_7seg u4(3'b100, HEX4);
	
//=======================================================
//  Structural coding
//=======================================================

endmodule

// implements a 7-segment decoder for d, E, 1 and 0
module char_7seg (C , Display);
	input [2:0] C; // input code
	output [6:0] Display; // output 7-seg code

	assign Display[0] = C[2] ? 1 : (~C[1]				);	//a
	assign Display[1] = C[2] ? 1 : (~(~C[1]|C[0])	);	//b
	assign Display[2] = C[2] ? 1 : (~(~C[1]|C[0])	);	//c
	assign Display[3] = C[2] ? 1 : (~(C[1]|~C[0])	);	//d
	assign Display[4] = C[2] ? 1 : (~(C[1]|~C[0])	);	//e
	assign Display[5] = C[2] ? 1 : (~C[1]				);	//f
	assign Display[6] = C[2] ? 0 : (C[0]				);	//g
endmodule


module rotate (in, out);
    input  [2 :0]in;
	 output [17:0]out;
	 // Decoding Circuit
	 assign out[0] = ~( in[0] & in[1] );                              //1 
	 assign out[1] = ( in[0] );                                       //2 
	 assign out[2] = ( in[0] ^ in[1] ) & ( in[2] );                    //3
	 assign out[3] = ( ~(in[0] ^ in[2] ) & ( ~in[1] ) );              //4
	 assign out[4] =  ( ( in[1] & in[2] ) | ( ~in[1] & ~in[2] ) );    //5 
	 assign out[5] =  ( ( in[0] ^ in[1] ) & ~in[2] );                 //
	 assign out[6] =  ( in[0] );                                      //
	 assign out[7] =  ( ~in[0] & in[1] );                             //
	 assign out[8] =  ( ~in[0] & in[2] );                             //
	 assign out[9] =  ( ( in[1] & in[2] ) | ( ~in[1] & ~in[2] ) );    //                   // 
	 assign out[10] = ( ~in[0] & ( in[1] ^ in[2] ) );        	       //
	 assign out[11] = ( ~( in[0] & in[2] ) );                         // 
 	 assign out[12] = ( (~ in[0] & in[1] ) );                         // 
	 assign out[13] = ( ~( in[0] & in[1] ) );                         //
	 assign out[14] = ( (~ in[1] & in[2] ) );                         //
	 assign out[15] = ( ~in[0] & (in[1] ^ in[2] ) );                  //        
	 assign out[16] = ( ~in[1] & ~(in[0] ^ in[2] ) );                 //       
	 assign out[17] = ( ~(in[0] & in[2] ) );                          //

endmodule	 
	

